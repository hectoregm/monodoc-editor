<!-- link.xsl   Scott Bronson   19 Oct 2002 -->

<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">

<!-- All links are generated by this file -->

<!-- TODO: now that all relative links have been eradicated, it's
     time to get rid of the "full-" in all the following names -->

<!-- This file requires that the "l" parameter already be set to
     the proper language (i.e. "en"). -->


<!-- creates a link.  This should be one of the few places that links
     are ever actually created.  Everything else should just call this -->
<!-- nsroot: root of the namespace (System/), not root of docs (en/)
     it turns out nsroot is everywhere. delete it and treat it like $l? -->
<xsl:template name="master-link">
  <xsl:param name="nsroot"/>  <!-- optional -->
  <xsl:param name="ns"/>
  <xsl:param name="class"/>
  <xsl:param name="content"/>
  <xsl:param name="xsl"/>
  <xsl:param name="mark"/> <!-- optional -->
  <xsl:param name="view"/> <!-- optional -->
  <xsl:param name="member"/> <!-- optional -->

  <xsl:variable name="mk">
    <xsl:if test="string-length($mark)>0">
      <xsl:value-of select="concat('#', $mark)"/>
    </xsl:if>
  </xsl:variable>

  <xsl:variable name="rt">
    <xsl:if test="$nsroot">
      <xsl:value-of select="concat($nsroot, '.././')"/>
    </xsl:if>
  </xsl:variable>

  <xsl:variable name="vw">
    <xsl:if test="$view">
      <xsl:value-of select="concat(',view=', $view)"/>
    </xsl:if>
  </xsl:variable>

  <xsl:variable name="m">
    <xsl:if test="$member">
      <xsl:value-of select="concat(',m=', $member)"/>
    </xsl:if>
  </xsl:variable>

  <a href="{$rt}{$l}/{$ns}/{$class}.xml,{$xsl}[l={$l}{$m}{$vw}].html{$mk}">
    <xsl:copy-of select="$content"/>
  </a>
</xsl:template>


<!-- Creates a link to a fully-qualified class -->
<xsl:template name="full-link">
  <xsl:param name="nsroot"/>  <!-- optional -->
  <xsl:param name="fulltype"/>
  <xsl:param name="content"/>
  <xsl:param name="xsl"/>
  <xsl:param name="mark"/> <!-- optional -->
  <xsl:param name="view"/> <!-- optional -->
  <xsl:param name="member"/> <!-- optional -->

  <xsl:call-template name="master-link">
    <xsl:with-param name="nsroot" select="$nsroot"/>
    <xsl:with-param name="content" select="$content"/>
    <xsl:with-param name="ns">
      <xsl:call-template name="base-name">
        <xsl:with-param name="string" select="$fulltype"/>
      </xsl:call-template>
    </xsl:with-param>
    <xsl:with-param name="class">
      <xsl:call-template name="leaf-name">
        <!-- make sure arrays don't corrupt the xml file name -->
        <xsl:with-param name="string" select="translate($fulltype, '*[]&amp;', '')"/>
      </xsl:call-template>
    </xsl:with-param>
    <xsl:with-param name="xsl" select="$xsl"/>
    <xsl:with-param name="mark" select="$mark"/>
    <xsl:with-param name="view" select="$view"/>
    <xsl:with-param name="member" select="$member"/>
  </xsl:call-template>
</xsl:template>


<!-- creates a link to the summary page -->
<xsl:template name="full-summary-link">
  <xsl:param name="nsroot"/>  <!-- optional -->
  <xsl:param name="fulltype"/>
  <xsl:param name="content"/> <!-- optional -->
  <xsl:param name="mark"/> <!-- optional -->

  <xsl:variable name="cnt">
    <xsl:choose>
      <xsl:when test="$content">
        <xsl:copy-of select="$content"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:call-template name="leaf-name">
          <xsl:with-param name="string" select="$fulltype"/>
        </xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:call-template name="full-link">
    <xsl:with-param name="nsroot" select="$nsroot"/>
    <xsl:with-param name="fulltype" select="$fulltype"/>
    <xsl:with-param name="content" select="$cnt"/>
    <xsl:with-param name="xsl" select="'summary.xsl'"/>
    <xsl:with-param name="mark" select="$mark"/>
  </xsl:call-template>
</xsl:template>


<!-- we don't currently treat langwords as linkable -->
<xsl:template name="langword-link">
  <xsl:param name="nsroot"/>  <!-- optional -->
  <xsl:param name="langword"/>

  <tt><b><xsl:value-of select="$langword"/></b></tt>
</xsl:template>


<!-- links to a field -->
<xsl:template name="full-field-link">
  <xsl:param name="nsroot"/>  <!-- optional -->
  <xsl:param name="fullfield"/>
  <xsl:param name="content"/> <!-- optional -->
  <xsl:param name="qualify"/> <!-- optional -->

  <!-- fill in content if unspecified -->
  <xsl:variable name="cont">
    <xsl:choose>
      <xsl:when test="$content">
        <xsl:value-of select="$content"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:call-template name="qualified-name">
	  <xsl:with-param name="fullname" select="$fullfield"/>
	  <xsl:with-param name="qualify" select="$qualify"/>
	</xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:call-template name="full-link">
    <xsl:with-param name="nsroot" select="$nsroot"/>
    <xsl:with-param name="fulltype">
      <xsl:call-template name="base-name">
        <xsl:with-param name="string" select="$fullfield"/>
      </xsl:call-template>
    </xsl:with-param>
    <xsl:with-param name="content" select="$cont"/>
    <xsl:with-param name="xsl" select="'item.xsl'"/>
    <xsl:with-param name="member">
      <xsl:call-template name="leaf-name">
        <xsl:with-param name="string" select="$fullfield"/>
      </xsl:call-template>
    </xsl:with-param>
  </xsl:call-template>
</xsl:template>


<!-- links to the named method in the named class -->
<!-- handles .ctors properly -->
<xsl:template name="full-method-link">
  <xsl:param name="nsroot"/>  <!-- optional -->
  <xsl:param name="fullmethod"/> <!-- params(*) after method are optional -->
  <xsl:param name="overload"/> <!-- optional -->
  <xsl:param name="qualify"/>
  <xsl:param name="content"/> <!-- optional -->

  <!-- internal - don't use.  Call full-parameter-link instead -->
  <xsl:param name="internparam"/>

  <!-- the fully qualified method name, no params -->
  <xsl:variable name="fullname">
    <xsl:choose>
      <xsl:when test="contains($fullmethod,'(')">
        <xsl:value-of select="substring-before($fullmethod,'(')"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$fullmethod"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <!-- the fully qualified type (fullname minus method name) -->
  <!-- person who made starts-with but not ends-with should be SHOT. -->
  <xsl:variable name="fulltype">
    <xsl:choose>
      <xsl:when test="substring($fullname, 1+string-length($fullname)-string-length('..ctor'))='..ctor'">
        <xsl:value-of select="substring($fullname, 1, string-length($fullname)-string-length('..ctor'))"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:call-template name="base-name">
          <xsl:with-param name="string" select="$fullname"/>
        </xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <!-- the method's name, unqualified, non-readable -->
  <xsl:variable name="method">
    <xsl:choose>
      <xsl:when test="substring($fullname, 1+string-length($fullname)-string-length('..ctor'))='..ctor'">
        <xsl:value-of select="'.ctor'"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:call-template name="leaf-name">
          <xsl:with-param name="string" select="$fullname"/>
        </xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <!-- the method's short name, unqualified, readable -->
  <xsl:variable name="rmethod">
    <xsl:choose>
      <xsl:when test="substring($fullname, 1+string-length($fullname)-string-length('..ctor'))='..ctor'">
        <xsl:call-template name="leaf-name">
	  <xsl:with-param name="string" select="$fulltype"/>
	</xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
        <xsl:call-template name="leaf-name">
          <xsl:with-param name="string" select="$fullname"/>
        </xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <!-- fully-qualified, readable full name -->
  <xsl:variable name="rfullname">
    <xsl:choose>
      <xsl:when test="substring($fullname, 1+string-length($fullname)-string-length('..ctor'))='..ctor'">
        <xsl:value-of select="concat($fulltype, '.', $rmethod)"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$fullname"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>


  <!-- overload not specified but args are, try to calc ov from args -->
  <xsl:variable name="ov">
    <xsl:choose>
      <xsl:when test="$overload">
        <xsl:value-of select="$overload"/>
      </xsl:when>
      <xsl:otherwise>
        <!-- remove whitespace and parens from argument list -->
        <xsl:value-of select="translate(substring-before(substring-after($fullmethod,'('),')'),' ','')"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <!-- fill in content if unspecified -->
  <xsl:variable name="cont">
    <xsl:choose>
      <xsl:when test="$content">
        <xsl:copy-of select="$content"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:call-template name="qualified-name">
	  <xsl:with-param name="fullname" select="$rfullname"/>
	  <xsl:with-param name="qualify" select="$qualify"/>
	</xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <!-- calc mark: made up of ov args and optional param -->
  <xsl:variable name="mk">
    <xsl:choose>
      <xsl:when test="$internparam">
        <xsl:if test="not($ov)">
	  <xsl:message terminate="yes">
	    You must specify an overload somehow
	    if you want to create a parameter link!
	  </xsl:message>
	</xsl:if>
	<xsl:value-of select="concat($ov, '-', $internparam)"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$ov"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:if test="0">
    <!-- a bit of debugging -->
    <hr></hr>
    FULLNAME(<xsl:value-of select="$fullname"/>)
    FULLTYPE(<xsl:value-of select="$fulltype"/>)
    METHOD(<xsl:value-of select="$method"/>)
    RMETHOD(<xsl:value-of select="$rmethod"/>)
    RFULLNAME(<xsl:value-of select="$rfullname"/>)
    OV(<xsl:value-of select="$ov"/>)
    CONT(<xsl:value-of select="$cont"/>)
    MK(<xsl:value-of select="$mk"/>)
    <hr></hr>
  </xsl:if>

  <xsl:call-template name="full-link">
    <xsl:with-param name="nsroot" select="$nsroot"/>
    <xsl:with-param name="fulltype" select="$fulltype"/>
    <xsl:with-param name="content" select="$cont"/>
    <xsl:with-param name="xsl" select="'item.xsl'"/>
    <xsl:with-param name="mark" select="$mk"/>
    <xsl:with-param name="member" select="$method"/>
  </xsl:call-template>
</xsl:template>


<!-- creates a link to the parameter of the method of the type -->
<xsl:template name="full-parameter-link">
  <xsl:param name="nsroot"/>  <!-- optional -->
  <xsl:param name="fullmethod"/>
  <xsl:param name="overload"/>
  <xsl:param name="parameter"/>
  <xsl:param name="qualify"/> <!-- optional, defaults to false -->
  <xsl:param name="content"/> <!-- optional -->

  <!-- fill in content if unspecified -->
  <xsl:variable name="cont">
    <xsl:choose>
      <xsl:when test="$content">
        <xsl:value-of select="$content"/>
      </xsl:when>
      <xsl:otherwise>
        <!-- the following <i> tags appear to tickle a bug in
	Sablotron 0.95.  For some reason, it injects a strange
	xmlns:xsl="..." attribute.  Doesn't seem to hurt anything. -->
        <i><xsl:value-of select="$parameter"/></i>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:call-template name="full-method-link">
    <xsl:with-param name="nsroot" select="$nsroot"/>
    <xsl:with-param name="fullmethod" select="$fullmethod"/>
    <xsl:with-param name="overload" select="$overload"/>
    <xsl:with-param name="qualify" select="$qualify"/>
    <xsl:with-param name="content" select="$cont"/>
    <xsl:with-param name="internparam" select="$parameter"/>
  </xsl:call-template>
</xsl:template>


<!-- links to the property -->
<xsl:template name="full-property-link">
  <xsl:param name="nsroot"/>  <!-- optional -->
  <xsl:param name="fullprop"/>
  <xsl:param name="content"/> <!-- optional -->
  <xsl:param name="qualify"/> <!-- optional -->

  <!-- fill in content if unspecified -->
  <xsl:variable name="cont">
    <xsl:choose>
      <xsl:when test="$content">
        <xsl:value-of select="$content"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:call-template name="qualified-name">
	  <xsl:with-param name="fullname" select="$fullprop"/>
	  <xsl:with-param name="qualify" select="$qualify"/>
	</xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:call-template name="full-link">
    <xsl:with-param name="nsroot" select="$nsroot"/>
    <xsl:with-param name="fulltype">
      <xsl:call-template name="base-name">
        <xsl:with-param name="string" select="$fullprop"/>
      </xsl:call-template>
    </xsl:with-param>
    <xsl:with-param name="content" select="$cont"/>
    <xsl:with-param name="xsl" select="'item.xsl'"/>
    <xsl:with-param name="member">
      <xsl:call-template name="leaf-name">
        <xsl:with-param name="string" select="$fullprop"/>
      </xsl:call-template>
    </xsl:with-param>
  </xsl:call-template>
</xsl:template>


<xsl:template name="full-event-link">
  <xsl:param name="nsroot"/>  <!-- optional -->
  <xsl:param name="fullevent"/>
  <xsl:param name="content"/> <!-- optional -->
  <xsl:param name="qualify"/> <!-- optional -->

  <!-- fill in content if unspecified -->
  <xsl:variable name="cont">
    <xsl:choose>
      <xsl:when test="$content">
        <xsl:value-of select="$content"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:call-template name="qualified-name">
	  <xsl:with-param name="fullname" select="$fullevent"/>
	  <xsl:with-param name="qualify" select="$qualify"/>
	</xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:call-template name="full-link">
    <xsl:with-param name="nsroot" select="$nsroot"/>
    <xsl:with-param name="fulltype">
      <xsl:call-template name="base-name">
        <xsl:with-param name="string" select="$fullevent"/>
      </xsl:call-template>
    </xsl:with-param>
    <xsl:with-param name="content" select="$cont"/>
    <xsl:with-param name="xsl" select="'item.xsl'"/>
    <xsl:with-param name="member">
      <xsl:call-template name="leaf-name">
        <xsl:with-param name="string" select="$fullevent"/>
      </xsl:call-template>
    </xsl:with-param>
  </xsl:call-template>
</xsl:template>


<!-- links to the type -->
<xsl:template name="full-type-link">
  <xsl:param name="nsroot"/>  <!-- optional -->
  <xsl:param name="fulltype"/>
  <xsl:param name="qualify"/>
  <xsl:param name="content"/>

  <!-- fill in content if unspecified -->
  <xsl:variable name="cont">
    <xsl:choose>
      <xsl:when test="$content">
        <xsl:value-of select="$content"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:call-template name="qualified-name">
	  <xsl:with-param name="fullname" select="$fulltype"/>
	  <xsl:with-param name="qualify" select="$qualify"/>
	</xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:call-template name="full-summary-link">
    <xsl:with-param name="nsroot" select="$nsroot"/>
    <xsl:with-param name="fulltype" select="$fulltype"/>
    <xsl:with-param name="content" select="$cont"/>
  </xsl:call-template>
</xsl:template>


<!-- links to the (exception?) -->
<!-- TODO: use anchors to scroll immediately to the member -->
<xsl:template name="full-bang-link">
  <xsl:param name="nsroot"/>  <!-- optional -->
  <xsl:param name="fullbang"/>
  <xsl:param name="qualify"/>

  <xsl:call-template name="full-summary-link">
    <xsl:with-param name="nsroot" select="$nsroot"/>
    <xsl:with-param name="fulltype">
      <xsl:call-template name="base-name">
        <xsl:with-param name="string" select="$fullbang"/>
      </xsl:call-template>
    </xsl:with-param>
    <xsl:with-param name="content" select="concat($fullbang, ' (!)')"/>
  </xsl:call-template>
</xsl:template>



<!-- links to a page listing fulltype's members of the given type -->
<xsl:template name="members-by-type-link">
  <xsl:param name="nsroot"/>  <!-- optional -->
  <xsl:param name="fulltype"/>
  <xsl:param name="content"/>
  <xsl:param name="type"/> <!-- optional -->
  
  <xsl:call-template name="full-link">
    <xsl:with-param name="nsroot" select="$nsroot"/>
    <xsl:with-param name="fulltype" select="$fulltype"/>
    <xsl:with-param name="content" select="$content"/>
    <xsl:with-param name="xsl" select="'members.xsl'"/>
    <xsl:with-param name="view" select="'t'"/>
    <xsl:with-param name="mark" select="$type"/>
  </xsl:call-template>
</xsl:template>


<!-- links to a page listing fulltype's members of the specified access -->
<xsl:template name="members-by-access-link">
  <xsl:param name="nsroot"/>  <!-- optional -->
  <xsl:param name="fulltype"/>
  <xsl:param name="content"/>
  <xsl:param name="access"/> <!-- optional -->

  <xsl:call-template name="full-link">
    <xsl:with-param name="nsroot" select="$nsroot"/>
    <xsl:with-param name="fulltype" select="$fulltype"/>
    <xsl:with-param name="content" select="$content"/>
    <xsl:with-param name="xsl" select="'members.xsl'"/>
    <xsl:with-param name="view" select="'a'"/>
    <xsl:with-param name="mark" select="$access"/>
  </xsl:call-template>
</xsl:template>


<!-- links to a page listing all fulltype's members by name -->
<xsl:template name="members-by-name-link">
  <xsl:param name="nsroot"/>  <!-- optional -->
  <xsl:param name="fulltype"/>
  <xsl:param name="content"/>

  <xsl:call-template name="full-link">
    <xsl:with-param name="nsroot" select="$nsroot"/>
    <xsl:with-param name="fulltype" select="$fulltype"/>
    <xsl:with-param name="content" select="$content"/>
    <xsl:with-param name="xsl" select="'members.xsl'"/>
    <xsl:with-param name="view" select="'n'"/>
  </xsl:call-template>
</xsl:template>


<!-- creates a link to a namespace NS read from masterdoc MASTER -->
<!-- pass "" for NS to specify the root namespace. -->

<xsl:template name="namespace-link">
  <xsl:param name="nsroot"/>  <!-- optional -->
  <xsl:param name="ns"/>
  <xsl:param name="assembly"/>
  <xsl:param name="content"/>

  <xsl:variable name="rt">
    <xsl:if test="$nsroot">
      <xsl:value-of select="concat($nsroot, '.././')"/>
    </xsl:if>
  </xsl:variable>

  <a href="{$rt}{$assembly}.xml,namespace.xsl[l={$l},ns={$ns}].html">
    <xsl:copy-of select="$content"/>
  </a>
</xsl:template>


<!-- this is just a placeholder for future functionality -->

<xsl:template name="bad-link">
  <xsl:param name="content"/>

  <a href="BAD-LINK">
    <xsl:copy-of select="$content"/>
  </a>
</xsl:template>

<!-- checks the qualify param to see whether we should run leaf-name
on the fullname or not.  defaults to unqualified -->
<xsl:template name="qualified-name">
  <xsl:param name="fullname"/>
  <xsl:param name="qualify"/>

  <xsl:choose>
    <xsl:when test="substring($qualify,1,1)='t'">
      <xsl:value-of select="$fullname"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:call-template name="leaf-name">
        <xsl:with-param name="string" select="$fullname"/>
      </xsl:call-template>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>


<!-- Finds the text after the last period -->
<!-- i.e. System.Object.Equals => Equals -->
<!-- If no period, it returns the entire string -->

<xsl:template name="leaf-name">
  <xsl:param name="string"/>
  <xsl:choose>
    <xsl:when test="substring-after($string,'.')">
      <xsl:call-template name="leaf-name">
        <xsl:with-param name="string" select="substring-after($string,'.')"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="$string"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>


<!-- Finds the text before the last period -->
<!-- i.e. System.Object.Equals => System.Object -->
<!-- if no period, it returns the empty string -->

<xsl:template name="base-name">
  <xsl:param name="string"/>
  <xsl:if test="contains($string,'.')">
    <xsl:variable name="leaf">
      <xsl:call-template name="leaf-name">
        <xsl:with-param name="string" select="$string"/>
      </xsl:call-template>
    </xsl:variable>
    <xsl:value-of select="substring($string, 1, string-length($string) - string-length($leaf) - 1)"/>
  </xsl:if>
</xsl:template>

</xsl:stylesheet>

